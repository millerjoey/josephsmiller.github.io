<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Record Linkage · Active Learning</title>
    <meta
      name="description"
      content="Upload CSVs, label a small number of pairs, and see active learning select the next most-informative match decisions."
    />
    <meta name="theme-color" content="#8b3a3a" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <main class="shell">
      <div class="topbar">
        <a class="text-link" href="index.html">&larr; Demos</a>
        <div class="topbar-links">
          <a class="text-link" href="https://josephsmiller.com/">Home</a>
          <div class="muted small" id="apiStatus"></div>
        </div>
      </div>

      <header>
        <div class="eyebrow">Record linkage demo</div>
        <h1>Record linkage with active learning</h1>
        <p class="lede">
          Deduplicate a file or link two files with far fewer labels. Instead of labeling random pairs, the system actively
          asks for the next pair that will teach the matcher the most—so you reach high-quality match probabilities quickly.
        </p>
        <p class="muted small" style="margin-top: 0.35rem">
          Early on you’ll see <strong>sim</strong> (raw similarity). After a few labels, you’ll see <strong>prob</strong> (calibrated
          match probability) and the queried pairs concentrate near <code>p≈0.5</code>.
        </p>
        <ol class="muted small" style="margin: 0.7rem 0 0; padding-left: 1.15rem">
          <li>Upload CSV(s)</li>
          <li>Label 10–30 pairs</li>
          <li>Run full scoring + download results</li>
        </ol>
      </header>

      <section class="panel" aria-label="How it works">
        <h2>How it works</h2>
        <ul class="muted small" style="margin: 0; padding-left: 1.15rem">
          <li>Compute many string-distance similarity features from record text (e.g., a <code>text</code>/<code>name</code> column).</li>
          <li>Compress features with PCA into a small embedding (principal components).</li>
          <li>Fit ridge logistic regression on PCs to predict match probability.</li>
          <li>Actively choose the next pairs to label to reduce uncertainty fastest (often near <code>p≈0.5</code>).</li>
          <li>Query strategy: start with diverse pairs, then pick batches that maximize expected information gain (entropy reduction).</li>
        </ul>
        <p class="muted small" style="margin-top: 0.75rem">
          As labels accumulate, the backend can increase capacity by using more PCs.
        </p>
      </section>

      <section class="panel" aria-label="Backend note">
        <div class="tag">Hosted API demo</div>
        <p class="muted">
          This page calls a hosted backend API. Uploads are processed for your session and used only to fit the in-session
          matcher (not for training outside your run). Data may be cached temporarily to generate outputs and is not
          intended to be retained as a dataset.
        </p>
        <p class="muted small" style="margin-top: 0.6rem">
          The backend is efficient and designed to run in a tiny compute footprint (CPU-only).
        </p>
        <p class="muted small" style="margin-top: 0.6rem">
          If you need a private deployment or a higher-throughput trial environment, email
          <a class="text-link" href="mailto:joe@josephsmiller.com">joe@josephsmiller.com</a>.
        </p>
      </section>

      <section class="panel" aria-label="Connect and upload">
        <h2>Upload</h2>
        <div class="row" style="margin-top: 0.9rem">
          <label class="field">
            <span>API token (optional)</span>
            <input id="apiToken" type="password" placeholder="(optional)" autocomplete="off" />
          </label>
          <button id="apiTokenApply" class="button secondary small" type="button">Use token</button>
          <button id="apiTokenReset" class="button secondary small" type="button">Clear</button>
        </div>
        <p id="tokenHint" class="muted small" style="margin-top: 0.6rem; display: none">
          This server requires a token. Request a demo token:
          <a class="text-link" href="mailto:joe@josephsmiller.com?subject=Record%20linkage%20demo%20token">email me</a>.
        </p>
        <p class="muted small" style="margin-top: 0.6rem">
          For a hosted trial, request a demo token:
          <a class="text-link" href="mailto:joe@josephsmiller.com?subject=Record%20linkage%20demo%20token">email me</a>.
        </p>

        <div class="row" style="margin-top: 1rem">
          <label class="field">
            <span>Left CSV (required)</span>
            <input id="leftFile" type="file" accept=".csv" />
          </label>
          <label class="field">
            <span>Right CSV (optional)</span>
            <input id="rightFile" type="file" accept=".csv" />
          </label>
          <button id="upload" class="button" type="button">Upload</button>
        </div>

        <div class="actions" style="margin-top: 0.7rem">
          <label class="field compact" style="min-width: 260px">
            <span>Sample dataset</span>
            <select id="sampleDataset">
              <option value="dedup">Dedup sample (one CSV)</option>
              <option value="linkage_people">Linkage sample: people (two CSVs)</option>
              <option value="linkage_companies">Linkage sample: companies (two CSVs)</option>
            </select>
          </label>
          <a id="sampleLeft" class="button secondary small" href="#" download="left_sample.csv">Download sample left CSV</a>
          <a id="sampleRight" class="button secondary small" href="#" download="right_sample.csv"
            >Download sample right CSV</a
          >
        </div>

        <p class="muted small" style="margin-top: 0.6rem">
          CSV format (hosted demo): the backend uses a <code>text</code> column if present, else <code>name</code>, else the first
          column, and ignores other columns. Tip: concatenate multiple fields into a single <code>text</code> column (e.g., name +
          address) for better matching.
        </p>
        <p class="muted small" style="margin-top: 0.4rem">
          Sample datasets are optional — you can upload your own CSVs instead (subject to demo limits enforced by the
          backend).
        </p>

        <p id="uploadStatus" class="muted small" style="margin-top: 0.9rem"></p>
        <input id="jobId" type="hidden" />
      </section>

      <section class="panel" aria-label="Label pairs">
        <h2>Label</h2>
        <div class="row">
          <label class="field compact">
            <span>Batch size</span>
            <input id="batchSize" type="number" min="1" max="100" step="1" value="10" />
          </label>
          <label class="field compact">
            <span>
              Auto-suggest threshold (prob)
              <span
                class="muted small"
                title="Only auto-fills when the model is extremely confident. Uncertain pairs are left blank."
                style="margin-left: 0.3rem; cursor: help"
                >?</span
              >
            </span>
            <input id="autoThresh" type="number" min="0.5" max="0.99" step="0.05" value="0.9" />
          </label>
          <button id="loadBatch" class="button secondary" type="button" disabled>Load batch</button>
          <button id="submitLabels" class="button" type="button" disabled>Submit labels</button>
        </div>
        <p class="muted small" style="margin-top: 0.55rem">
          Suggestions only apply to high-confidence probabilities; correct them if they're wrong. Uncertain pairs are left blank.
        </p>

        <div class="metrics" style="margin-top: 0.75rem">
          <div class="metric">
            <div class="metric-value" id="scoreMode">--</div>
            <div class="metric-label">Score shown</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="poolRemaining">--</div>
            <div class="metric-label">Pool remaining</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="pcsUsed" title="Not exposed by this API response.">--</div>
            <div class="metric-label">PCs used</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="varianceExplained" title="Not exposed by this API response.">--</div>
            <div class="metric-label">Variance explained</div>
          </div>
        </div>

        <p id="labelStatus" class="muted small" style="margin-top: 0.75rem"></p>
        <p class="muted small" style="margin-top: 0.5rem">
          Compared fields: this hosted backend compares the <code>text</code>/<code>name</code> column (or first column). Other
          deployments may compare multiple columns field-by-field.
        </p>

        <details class="details">
          <summary>Keyboard shortcuts</summary>
          <p class="muted small">
            <code>j/k</code> or <code>↑/↓</code>: move • <code>a</code>: match • <code>d</code>: no-match •
            <code>x</code>: skip • <code>s</code>: clear • <code>Enter</code>: submit • <code>Shift+N</code>: next batch
          </p>
        </details>

        <div id="pairList" class="pair-list" aria-live="polite"></div>
      </section>

      <section class="panel" aria-label="Results">
        <h2>Results</h2>
        <p class="muted small" style="margin-top: -0.2rem; margin-bottom: 0.8rem">
          <strong>Predictions</strong> = scored candidate pairs (with probabilities once you’ve labeled a few pairs).
          <strong>Matches</strong> = linkage-mode pairs above the backend match threshold. <strong>Clusters</strong> are generated only
          for dedup mode (linkage mode returns matches instead).
        </p>
        <ul class="muted small" style="margin: 0 0 0.9rem; padding-left: 1.15rem">
          <li><strong>predictions</strong>: review scores and choose a cutoff for your workflow</li>
          <li><strong>matches</strong>: linkage-mode “accept list” (mutual best matches above the backend threshold)</li>
          <li><strong>clusters</strong>: dedup-mode group IDs produced from clustering the scored similarities</li>
        </ul>
        <div class="actions">
          <button id="runFull" class="button secondary" type="button" disabled>Run full scoring</button>
          <a
            id="downloadPredictions"
            class="button secondary small"
            href="#"
            download
            style="display: none"
            >Download predictions</a
          >
          <a
            id="downloadMatches"
            class="button secondary small"
            href="#"
            download
            style="display: none"
            >Download matches</a
          >
          <a
            id="downloadClusters"
            class="button secondary small"
            href="#"
            download
            style="display: none"
            >Download clusters</a
          >
        </div>
        <p id="runStatus" class="muted small" style="margin-top: 0.75rem"></p>
        <div class="metrics">
          <div class="metric">
            <div class="metric-value" id="positivesCount">0</div>
            <div class="metric-label">Match labels</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="negativesCount">0</div>
            <div class="metric-label">No-match labels</div>
          </div>
        </div>
        <p class="muted small" style="margin-top: 0.8rem">
          Metrics update as you label batches. Use “Run full scoring” to generate downloadable outputs.
        </p>
        <p class="muted small">
          Questions or want a private deployment / higher-throughput environment?
          <a class="text-link" href="mailto:joe@josephsmiller.com">Email me</a>.
        </p>
      </section>
    </main>

    <script>
      (() => {
        "use strict";

        const $ = (id) => document.getElementById(id);

        const elements = {
          apiStatus: $("apiStatus"),
          apiToken: $("apiToken"),
          apiTokenApply: $("apiTokenApply"),
          apiTokenReset: $("apiTokenReset"),
          tokenHint: $("tokenHint"),
          leftFile: $("leftFile"),
          rightFile: $("rightFile"),
          sampleDataset: $("sampleDataset"),
          sampleLeft: $("sampleLeft"),
          sampleRight: $("sampleRight"),
          upload: $("upload"),
          uploadStatus: $("uploadStatus"),
          jobId: $("jobId"),
          batchSize: $("batchSize"),
          autoThresh: $("autoThresh"),
          loadBatch: $("loadBatch"),
          submitLabels: $("submitLabels"),
          labelStatus: $("labelStatus"),
          scoreMode: $("scoreMode"),
          poolRemaining: $("poolRemaining"),
          pcsUsed: $("pcsUsed"),
          varianceExplained: $("varianceExplained"),
          pairList: $("pairList"),
          runFull: $("runFull"),
          downloadPredictions: $("downloadPredictions"),
          downloadMatches: $("downloadMatches"),
          downloadClusters: $("downloadClusters"),
          runStatus: $("runStatus"),
          positivesCount: $("positivesCount"),
          negativesCount: $("negativesCount"),
        };

        // Hosted backend endpoint. Edit this constant if you move hosting.
        const API_BASE = "https://fuzzymatchingservice-production.up.railway.app";
        let API_TOKEN = "";
        let batch = [];
        let cursor = 0;
        let lastScoreKind = null; // "sim" | "prob"
        const uiState = {
          remaining: null,
          lastLabelSummary: "",
        };

        function setApiToken(nextToken, { persist = true } = {}) {
          API_TOKEN = (nextToken || "").trim();
          if (elements.apiToken) elements.apiToken.value = API_TOKEN;
          if (persist && window.localStorage) {
            if (API_TOKEN) localStorage.setItem("fuzzy_api_token", API_TOKEN);
            else localStorage.removeItem("fuzzy_api_token");
          }
        }

        function authHeaders(base = {}) {
          const headers = { ...(base || {}) };
          if (API_TOKEN) headers["X-API-Token"] = API_TOKEN;
          return headers;
        }

        function api(path) {
          return `${API_BASE}${path}`;
        }

        async function probe(url) {
          try {
            return await fetch(url, { method: "GET", headers: authHeaders() });
          } catch {
            return null;
          }
        }

        async function checkBackend() {
          elements.apiStatus.textContent = "Backend: checking…";
          elements.apiStatus.title = API_BASE;
          elements.upload.disabled = true;
          if (elements.tokenHint) elements.tokenHint.style.display = "none";
          const res =
            (await probe(api("/api/health"))) ||
            // Fallback probe that exists on older backends and includes CORS on 404.
            (await probe(api("/api/job/__ping__/next?batch=1")));
          if (!res) {
            elements.apiStatus.textContent = "Backend: offline";
            elements.apiStatus.title = API_BASE;
            elements.upload.disabled = true;
            return false;
          }
          if (res.status === 401) {
            elements.apiStatus.textContent = "Backend: token required";
            if (elements.tokenHint) elements.tokenHint.style.display = "block";
          } else {
            elements.apiStatus.textContent = res.ok ? "Backend: connected" : "Backend: reachable";
          }
          elements.upload.disabled = false;
          return true;
        }

        function resetDownloads() {
          for (const el of [
            elements.downloadPredictions,
            elements.downloadMatches,
            elements.downloadClusters,
          ]) {
            el.style.display = "none";
            el.removeAttribute("href");
            el.removeAttribute("target");
            el.removeAttribute("rel");
          }
        }

        function updateDownloads(artifacts) {
          resetDownloads();
          const jobId = elements.jobId.value;
          const mapping = {
            predictions: elements.downloadPredictions,
            matches: elements.downloadMatches,
            clusters: elements.downloadClusters,
          };

          for (const name of artifacts || []) {
            const el = mapping[name];
            if (!el) continue;
            el.href = api(`/api/job/${encodeURIComponent(jobId)}/download/${encodeURIComponent(name)}`);
            el.style.display = "inline-flex";
            el.target = "_blank";
            el.rel = "noopener";
          }
        }

        function renderMessage(message) {
          elements.pairList.innerHTML = "";
          const el = document.createElement("p");
          el.className = "muted small";
          el.textContent = message;
          elements.pairList.appendChild(el);
        }

        function updateLabelStatus() {
          const parts = [];
          if (uiState.lastLabelSummary) parts.push(uiState.lastLabelSummary);
          if (lastScoreKind === "sim")
            parts.push("Model not trained yet. Label a few pairs to learn a probability model.");
          if (lastScoreKind === "prob")
            parts.push("Model trained. Active learning will focus on uncertain pairs near p≈0.5.");
          if (Number.isFinite(uiState.remaining)) parts.push(`Pool remaining: ${uiState.remaining}.`);
          elements.labelStatus.textContent = parts.join(" ");
        }

        function firstFiniteNumber(...values) {
          for (const v of values) {
            const n = Number(v);
            if (Number.isFinite(n)) return n;
          }
          return null;
        }

        function updateModelMetrics(payload) {
          const meta = payload?.model || payload?.meta || payload || null;
          if (!meta) return;

          const pcsDirect = firstFiniteNumber(meta.pcs_used, meta.pcs, meta.n_pcs, meta.pc_count);
          const pCurrent = firstFiniteNumber(meta.p_current, meta.p_active, meta.feature_dim, meta.feature_dims);
          const pcsFromP = Number.isFinite(pCurrent) && pCurrent >= 2 ? pCurrent - 2 : null;
          const pcs = pcsDirect ?? pcsFromP;

          let varExplained = firstFiniteNumber(meta.variance_explained, meta.var_explained, meta.variance);
          if (!Number.isFinite(varExplained) && Array.isArray(meta.variance_explained)) {
            const tail = meta.variance_explained[meta.variance_explained.length - 1];
            varExplained = firstFiniteNumber(tail);
          }

          if (elements.pcsUsed && Number.isFinite(pcs)) {
            elements.pcsUsed.textContent = String(Math.max(0, Math.round(pcs)));
            elements.pcsUsed.removeAttribute("title");
          }
          if (elements.varianceExplained && Number.isFinite(varExplained)) {
            const v = varExplained > 1 ? varExplained / 100 : varExplained;
            if (v >= 0 && v <= 1) {
              elements.varianceExplained.textContent = `${(v * 100).toFixed(0)}%`;
              elements.varianceExplained.removeAttribute("title");
            }
          }
        }

        function toDataUrlCsv(csvText) {
          return `data:text/csv;charset=utf-8,${encodeURIComponent(csvText)}`;
        }

        function setSampleDataset(key) {
          const datasets = {
            dedup: {
              leftName: "dedup_sample.csv",
              leftCsv: `name
John Smith
Jon Smith
J. Smith
Jane Doe
Jane A. Doe
Janet Doe
ACME Corporation
Acme Corp.
Acme, Inc.
Globex LLC
Globex, L.L.C.
Initech
initech
Umbrella Co.
Umbrella Company
Soylent Corp
Soylent Corporation
Stark Industries
Stark Ind.
Wayne Enterprises
`,
              rightName: null,
              rightCsv: null,
            },
            linkage_people: {
              leftName: "linkage_people_left.csv",
              rightName: "linkage_people_right.csv",
              leftCsv: `name
Alex Johnson | 14 Cedar St | Austin TX
Maria Garcia | 55 Lakeview Dr | Phoenix AZ
Wei Chen | 220 Pine Ave | San Jose CA
Aisha Khan | 8 Market St | Chicago IL
Liam O'Connor | 77 River Rd | Boston MA
Sofia Martinez | 19 Sunset Blvd | Los Angeles CA
Noah Brown | 301 Elm St | Denver CO
Emma Wilson | 9 Birch Ln | Seattle WA
Olivia Davis | 410 Maple Rd | Portland OR
Ethan Miller | 600 Oak St | Dallas TX
Mia Anderson | 12 Spruce Ct | Miami FL
Jacob Thomas | 88 Highland Ave | Atlanta GA
Isabella Moore | 5 Cherry St | Raleigh NC
Lucas Martin | 2000 Park Ave | New York NY
Amelia Lee | 63 Ridge Rd | Newark NJ
Benjamin Clark | 1 Hill St | San Diego CA
Harper Lewis | 44 Forest Dr | Columbus OH
Daniel Walker | 72 Adams St | Minneapolis MN
Charlotte Hall | 16 King St | Nashville TN
Henry Young | 90 Queen St | Salt Lake City UT
`,
              rightCsv: `name
Alex J. Johnson | 14 Cedar Street | Austin Texas
Maria G. | 55 Lake View Dr | Phoenix AZ
Wei-Chen | 220 Pine Avenue | San Jose CA
Aisha Kahn | 8 Market Street | Chicago IL
Liam OConnor | 77 River Road | Boston MA
S. Martinez | 19 Sunset Boulevard | Los Angeles CA
Noah B. Brown | 301 Elm Street | Denver CO
Emma Willson | 9 Birch Lane | Seattle WA
Olivia D. | 410 Maple Road | Portland OR
Ethan Miler | 600 Oak Street | Dallas TX
Mia Andersson | 12 Spruce Court | Miami FL
Jacob T. | 88 Highland Avenue | Atlanta GA
Isabella M. Moore | 5 Cherry Street | Raleigh NC
Luke Martin | 2000 Park Avenue | New York NY
Amelia Li | 63 Ridge Road | Newark NJ
Ben Clark | 1 Hill Street | San Diego CA
Harper L. | 44 Forest Drive | Columbus OH
Dan Walker | 72 Adams Street | Minneapolis MN
Charlotte H. | 16 King Street | Nashville TN
Henry Yong | 90 Queen Street | Salt Lake City UT
`,
            },
            linkage_companies: {
              leftName: "linkage_companies_left.csv",
              rightName: "linkage_companies_right.csv",
              leftCsv: `name
Acme Corporation
Globex LLC
Initech
Umbrella Company
Soylent Corporation
Stark Industries
Wayne Enterprises
Wonka Industries
Hooli
Vandelay Industries
Massive Dynamic
Cyberdyne Systems
Tyrell Corporation
Oceanic Airlines
Pied Piper
Gekko & Co.
Duff Brewing Co.
Monsters Incorporated
Gringotts Bank
Prestige Worldwide
`,
              rightCsv: `name
Acme Corp.
Globex, L.L.C.
Initech Inc
Umbrella Co.
Soylent Corp
Stark Ind.
Wayne Ent.
Wonka Ind.
Hooli, Inc.
Vandelay Ind.
Massive Dynamic LLC
Cyberdyne Systemz
Tyrell Corp.
Oceanic Air Lines
PiedPiper
Gekko and Company
Duff Brewing Company
Monsters, Inc.
Gringotts Bank Ltd
Prestige Worldwide, LLC
`,
            },
          };

          const normalizedKey = key === "linkage_orgs" ? "linkage_companies" : key;
          const ds = datasets[normalizedKey] || datasets.dedup;
          if (elements.sampleLeft) {
            elements.sampleLeft.href = toDataUrlCsv(ds.leftCsv);
            elements.sampleLeft.download = ds.leftName;
          }
          if (elements.sampleRight) {
            if (ds.rightCsv) {
              elements.sampleRight.href = toDataUrlCsv(ds.rightCsv);
              elements.sampleRight.download = ds.rightName || "right_sample.csv";
              elements.sampleRight.style.display = "inline-flex";
            } else {
              elements.sampleRight.removeAttribute("href");
              elements.sampleRight.style.display = "none";
            }
          }
        }

        function scoreDisplay(item) {
          const score =
            item.is_probability && Number.isFinite(item.prob) ? item.prob : item.similarity;
          const value = Number.isFinite(score) ? score : 0;
          return {
            value,
            percent: `${(value * 100).toFixed(1)}%`,
            kind: item.is_probability ? "prob" : "sim",
          };
        }

        function normalizeAutoThresh(raw) {
          const n = Number(raw);
          if (!Number.isFinite(n)) return 0.9;
          return Math.max(0.5, Math.min(0.99, n));
        }

        function suggestLabel(item, autoThresh) {
          if (!item?.is_probability) return null;
          const p = Number(item.prob);
          if (!Number.isFinite(p)) return null;
          if (p >= autoThresh) return 1;
          if (p <= 1 - autoThresh) return 0;
          return null;
        }

        function confidenceChip(item, autoThresh) {
          if (!item?.is_probability) return null;
          const p = Number(item.prob);
          if (!Number.isFinite(p)) return null;
          if (p >= autoThresh) return { text: "status: high-conf match", title: "Model probability is well above 0.5." };
          if (p <= 1 - autoThresh)
            return { text: "status: high-conf non-match", title: "Model probability is well below 0.5." };
          return { text: "status: uncertain", title: "Near the decision boundary (p≈0.5)." };
        }

        function extraFieldsForDisplay(item) {
          const known = new Set(["left", "right", "i", "j", "similarity", "prob", "is_probability"]);
          const extra = {};
          for (const [k, v] of Object.entries(item || {})) {
            if (known.has(k)) continue;
            if (typeof v === "string") {
              extra[k] = v.length > 400 ? `${v.slice(0, 400)}…` : v;
            } else if (typeof v === "number" || typeof v === "boolean" || v === null) {
              extra[k] = v;
            } else {
              try {
                const s = JSON.stringify(v);
                extra[k] = s && s.length > 800 ? `${s.slice(0, 800)}…` : v;
              } catch {
                extra[k] = String(v);
              }
            }
          }
          return extra;
        }

        function keyFor(item) {
          return `${item.i}:${item.j}`;
        }

        function selectCursor(next) {
          cursor = Math.max(0, Math.min(batch.length - 1, next));
          const cards = elements.pairList.querySelectorAll(".pair");
          cards.forEach((card) => card.classList.remove("is-active"));
          const active = cards[cursor];
          if (active) {
            active.classList.add("is-active");
            active.scrollIntoView({ block: "nearest" });
          }
        }

        function refreshChoices() {
          const wrappers = elements.pairList.querySelectorAll(".choice");
          wrappers.forEach((wrapper) => {
            const input = wrapper.querySelector("input");
            wrapper.classList.toggle("selected", Boolean(input?.checked));
          });
          elements.submitLabels.disabled =
            elements.pairList.querySelectorAll('input[type="radio"]:checked:not([value="skip"])').length === 0;
        }

        function setChoice(key, value) {
          const input = elements.pairList.querySelector(
            `input[name="lbl_${key}"][value="${String(value)}"]`,
          );
          if (!input) return;
          input.checked = true;
          refreshChoices();
        }

        function clearChoice(key) {
          const inputs = elements.pairList.querySelectorAll(`input[name="lbl_${key}"]`);
          inputs.forEach((input) => {
            input.checked = false;
          });
          refreshChoices();
        }

        function renderBatch(items) {
          batch = Array.isArray(items) ? items : [];
          cursor = 0;
          elements.pairList.innerHTML = "";

          if (!batch.length) {
            renderMessage("No more pairs to label.");
            elements.submitLabels.disabled = true;
            lastScoreKind = null;
            if (elements.scoreMode) elements.scoreMode.textContent = "--";
            updateLabelStatus();
            return;
          }

          const autoThresh = normalizeAutoThresh(elements.autoThresh.value || "0.9");
          lastScoreKind = batch.some((it) => it && it.is_probability) ? "prob" : "sim";
          if (elements.scoreMode) elements.scoreMode.textContent = lastScoreKind;

          const fragment = document.createDocumentFragment();
          batch.forEach((item, index) => {
            const key = keyFor(item);
            const { value, percent, kind } = scoreDisplay(item);

            const card = document.createElement("div");
            card.className = "pair";
            card.dataset.key = key;
            card.dataset.index = String(index);

            const meta = document.createElement("div");
            meta.className = "muted small";
            meta.style.marginBottom = "0.55rem";
            meta.textContent = `pair: i=${item.i}, j=${item.j}`;

            const top = document.createElement("div");
            top.className = "pair-top";

            const names = document.createElement("div");
            names.className = "pair-names";

            const left = document.createElement("div");
            const leftLabel = document.createElement("div");
            leftLabel.className = "pair-label";
            leftLabel.textContent = "Left";
            const leftValue = document.createElement("div");
            leftValue.className = "pair-value";
            leftValue.textContent = item.left ?? "";
            left.append(leftLabel, leftValue);

            const right = document.createElement("div");
            const rightLabel = document.createElement("div");
            rightLabel.className = "pair-label";
            rightLabel.textContent = "Right";
            const rightValue = document.createElement("div");
            rightValue.className = "pair-value";
            rightValue.textContent = item.right ?? "";
            right.append(rightLabel, rightValue);

            names.append(left, right);

            const score = document.createElement("div");
            score.className = "pair-score";
            const pill = document.createElement("span");
            pill.className = "pill";
            pill.textContent = kind;
            const scoreValue = document.createElement("span");
            scoreValue.className = "score";
            scoreValue.textContent = percent;
            score.append(pill);
            const chip = confidenceChip(item, autoThresh);
            if (chip) {
              const chipEl = document.createElement("span");
              chipEl.className = "pill";
              chipEl.textContent = chip.text;
              chipEl.title = chip.title;
              score.appendChild(chipEl);
            }
            score.appendChild(scoreValue);

            top.append(names, score);

            const actions = document.createElement("div");
            actions.className = "pair-actions";

            const makeChoice = (label, v) => {
              const wrapper = document.createElement("label");
              wrapper.className = "choice";
              wrapper.addEventListener("click", (e) => e.stopPropagation());
              const input = document.createElement("input");
              input.type = "radio";
              input.name = `lbl_${key}`;
              input.value = String(v);
              input.addEventListener("click", (e) => e.stopPropagation());
              input.addEventListener("change", refreshChoices);
              const text = document.createElement("span");
              text.textContent = label;
              wrapper.append(input, text);
              return { wrapper, input };
            };

            const match = makeChoice("match", 1);
            const noMatch = makeChoice("no-match", 0);
            const skip = makeChoice("skip", "skip");
            actions.append(match.wrapper, noMatch.wrapper, skip.wrapper);

            card.append(meta, top, actions);
            card.addEventListener("click", () => selectCursor(index));

            const suggested = suggestLabel(item, autoThresh);
            if (suggested === 1) {
              match.input.checked = true;
              match.input.dataset.auto = "1";
            } else if (suggested === 0) {
              noMatch.input.checked = true;
              noMatch.input.dataset.auto = "1";
            }

            const extras = extraFieldsForDisplay(item);
            const extraKeys = Object.keys(extras);
            if (extraKeys.length) {
              const details = document.createElement("details");
              details.className = "details";
              const summary = document.createElement("summary");
              summary.textContent = "More fields";
              const pre = document.createElement("pre");
              pre.className = "muted small";
              pre.style.whiteSpace = "pre-wrap";
              pre.style.marginTop = "0.6rem";
              pre.textContent = JSON.stringify(extras, null, 2);
              details.append(summary, pre);
              card.appendChild(details);
            }

            fragment.appendChild(card);
          });

          elements.pairList.appendChild(fragment);
          refreshChoices();
          selectCursor(0);
          updateLabelStatus();
        }

        async function fetchJson(url, options) {
          let res;
          try {
            const opts = { ...(options || {}) };
            const baseHeaders = opts.headers && typeof opts.headers === "object" ? opts.headers : {};
            opts.headers = authHeaders(baseHeaders);
            res = await fetch(url, opts);
          } catch {
            throw new Error(`Cannot reach backend at ${API_BASE}.`);
          }
          const text = await res.text();
          let data = null;
          try {
            data = text ? JSON.parse(text) : null;
          } catch {
            // ignore
          }
          if (!res.ok) {
            let message = data?.error || text || `Request failed (${res.status})`;
            if (res.status === 401) {
              message = "Unauthorized. Provide a valid API token (or clear the token and try again).";
              if (elements.tokenHint) elements.tokenHint.style.display = "block";
              if (elements.apiToken) {
                elements.apiToken.focus();
                elements.apiToken.scrollIntoView({ block: "center", behavior: "smooth" });
              }
            } else if (res.status === 413) {
              message = "Upload too large for this demo server.";
            } else if (res.status === 429) {
              message = "Server is busy. Try again in a moment.";
            }
            const err = new Error(message);
            err.status = res.status;
            err.body = text;
            throw err;
          }
          return data;
        }

        async function pollReady(jobId) {
          elements.uploadStatus.textContent = "Processing…";
          for (let attempts = 0; attempts < 90; attempts++) {
            const data = await fetchJson(api(`/api/job/${encodeURIComponent(jobId)}`));
            if (data?.status === "ready") return;
            if (data?.status === "error") throw new Error(data.error || "Job failed");
            await new Promise((r) => setTimeout(r, 1000));
          }
          throw new Error("Timed out waiting for the engine to be ready.");
        }

        async function loadBatch() {
          const jobId = elements.jobId.value.trim();
          if (!jobId) throw new Error("Upload files first.");

          const batchSize = Math.max(1, Math.min(100, Number(elements.batchSize.value || "10")));
          const data = await fetchJson(
            api(`/api/job/${encodeURIComponent(jobId)}/next?batch=${batchSize}`),
          );
          updateModelMetrics(data);
          uiState.remaining = Number.isFinite(data?.remaining) ? data.remaining : null;
          renderBatch(data?.batch || []);
          if (elements.poolRemaining)
            elements.poolRemaining.textContent = Number.isFinite(uiState.remaining) ? String(uiState.remaining) : "--";
        }

        async function submitLabels() {
          const jobId = elements.jobId.value.trim();
          if (!jobId) throw new Error("Upload files first.");

          const inputs = elements.pairList.querySelectorAll('input[type="radio"]:checked');
          const labels = [];
          let autoSuggested = 0;
          inputs.forEach((input) => {
            if (input.value === "skip") return;
            const name = input.name || "";
            if (!name.startsWith("lbl_")) return;
            const key = name.slice(4);
            const [i, j] = key.split(":").map((n) => Number.parseInt(n, 10));
            if (!Number.isFinite(i) || !Number.isFinite(j)) return;
            labels.push({ i, j, label: Number.parseInt(input.value, 10) });
            if (input.dataset.auto === "1") autoSuggested += 1;
          });
          if (!labels.length) throw new Error("No labels selected.");

          if (autoSuggested >= 3 && autoSuggested >= Math.ceil(labels.length * 0.5)) {
            const ok = window.confirm(
              `You are submitting ${labels.length} labels (${autoSuggested} auto-suggested). Continue?`,
            );
            if (!ok) return;
          }

          const data = await fetchJson(api(`/api/job/${encodeURIComponent(jobId)}/label`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ labels }),
          });

          const count = data?.labeled_count ?? "?";
          const positives = data?.positives ?? "?";
          const negatives = data?.negatives ?? "?";
          uiState.lastLabelSummary = `Labeled: ${count} (${positives} match, ${negatives} no-match).`;
          if (elements.positivesCount) elements.positivesCount.textContent = String(positives);
          if (elements.negativesCount) elements.negativesCount.textContent = String(negatives);
          elements.runFull.disabled = false;
          elements.runStatus.textContent = "";
          await loadBatch();
        }

        async function runFull() {
          const jobId = elements.jobId.value.trim();
          if (!jobId) throw new Error("Upload files first.");
          elements.runFull.disabled = true;
          resetDownloads();
          elements.runStatus.textContent = "Running full scoring…";
          try {
            const data = await fetchJson(api(`/api/job/${encodeURIComponent(jobId)}/run_full`), {
              method: "POST",
            });
            updateDownloads(data?.artifacts || []);
            elements.runStatus.textContent = "Done. Downloads ready.";
          } finally {
            elements.runFull.disabled = false;
          }
        }

        elements.apiTokenApply.addEventListener("click", async () => {
          setApiToken(elements.apiToken.value);
          await checkBackend();
        });
        elements.apiTokenReset.addEventListener("click", async () => {
          setApiToken("");
          await checkBackend();
        });

        elements.upload.addEventListener("click", async () => {
          const left = elements.leftFile.files?.[0];
          const right = elements.rightFile.files?.[0];
          if (!left) {
            alert("Select a left CSV first.");
            return;
          }

          elements.upload.disabled = true;
          elements.loadBatch.disabled = true;
          elements.submitLabels.disabled = true;
          elements.runFull.disabled = true;
          resetDownloads();
          elements.labelStatus.textContent = "";
          uiState.remaining = null;
          uiState.lastLabelSummary = "";
          lastScoreKind = null;
          if (elements.scoreMode) elements.scoreMode.textContent = "--";
          if (elements.poolRemaining) elements.poolRemaining.textContent = "--";
          elements.runStatus.textContent = "";
          renderMessage("Uploading…");

          try {
            const fd = new FormData();
            fd.append("left", left);
            if (right) fd.append("right", right);

            const data = await fetchJson(api("/api/upload"), { method: "POST", body: fd });
            const jobId = data?.job_id;
            if (!jobId) throw new Error("Upload succeeded but job_id was missing.");
            elements.jobId.value = jobId;
            elements.uploadStatus.textContent = `Job: ${jobId}`;
            if (elements.positivesCount) elements.positivesCount.textContent = "0";
            if (elements.negativesCount) elements.negativesCount.textContent = "0";

            await pollReady(jobId);
            elements.uploadStatus.textContent = "Ready.";
            elements.loadBatch.disabled = false;
            elements.runFull.disabled = true;
            elements.runStatus.textContent = "Label at least one pair to enable full scoring.";
            await loadBatch();
          } catch (err) {
            console.error(err);
            elements.uploadStatus.textContent = `Error: ${err.message}`;
            renderMessage("Upload failed.");
          } finally {
            elements.upload.disabled = false;
          }
        });

        elements.loadBatch.addEventListener("click", async () => {
          elements.loadBatch.disabled = true;
          try {
            await loadBatch();
          } catch (err) {
            console.error(err);
            alert(err.message);
          } finally {
            elements.loadBatch.disabled = false;
          }
        });

        elements.submitLabels.addEventListener("click", async () => {
          elements.submitLabels.disabled = true;
          try {
            await submitLabels();
          } catch (err) {
            console.error(err);
            alert(err.message);
          } finally {
            refreshChoices();
          }
        });

        elements.runFull.addEventListener("click", async () => {
          try {
            await runFull();
          } catch (err) {
            console.error(err);
            alert(err.message);
            elements.runFull.disabled = false;
          }
        });

        document.addEventListener("keydown", (e) => {
          if (!batch.length) return;
          const target = e.target;
          const active = document.activeElement;
          const isEditable = (node) => {
            if (!(node instanceof HTMLElement)) return false;
            if (["INPUT", "TEXTAREA", "SELECT"].includes(node.tagName)) return true;
            if (node.isContentEditable) return true;
            if (node.closest && node.closest("[contenteditable='true']")) return true;
            return false;
          };
          if (isEditable(target) || isEditable(active)) return;

          const activeKey = batch[cursor] ? keyFor(batch[cursor]) : null;

          if (e.key === "ArrowDown" || e.key.toLowerCase() === "j") {
            selectCursor(cursor + 1);
            e.preventDefault();
          } else if (e.key === "ArrowUp" || e.key.toLowerCase() === "k") {
            selectCursor(cursor - 1);
            e.preventDefault();
          } else if (e.key.toLowerCase() === "d") {
            if (activeKey) setChoice(activeKey, 0);
            selectCursor(cursor + 1);
            e.preventDefault();
          } else if (e.key.toLowerCase() === "a") {
            if (activeKey) setChoice(activeKey, 1);
            selectCursor(cursor + 1);
            e.preventDefault();
          } else if (e.key.toLowerCase() === "x") {
            if (activeKey) setChoice(activeKey, "skip");
            selectCursor(cursor + 1);
            e.preventDefault();
          } else if (e.key.toLowerCase() === "s") {
            if (activeKey) clearChoice(activeKey);
            e.preventDefault();
          } else if (e.key === "Enter") {
            if (!elements.submitLabels.disabled) elements.submitLabels.click();
            e.preventDefault();
          } else if (e.key.toLowerCase() === "n" && e.shiftKey) {
            if (!elements.loadBatch.disabled) elements.loadBatch.click();
            e.preventDefault();
          }
        });

        async function initialize() {
          const storedToken = window.localStorage ? localStorage.getItem("fuzzy_api_token") : null;
          if (storedToken) {
            setApiToken(storedToken, { persist: false });
          }

          if (elements.sampleDataset) elements.sampleDataset.value = "dedup";
          setSampleDataset("dedup");
          if (elements.sampleDataset) {
            elements.sampleDataset.addEventListener("change", () => {
              setSampleDataset(elements.sampleDataset.value);
            });
          }

          if (elements.scoreMode) elements.scoreMode.textContent = "--";
          if (elements.poolRemaining) elements.poolRemaining.textContent = "--";

          await checkBackend();
        }

        renderMessage("Upload CSVs to start.");
        initialize();
      })();
    </script>
  </body>
</html>
